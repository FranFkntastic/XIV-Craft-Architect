@page "/market"
@using FFXIV_Craft_Architect.Core.Models
@using FFXIV_Craft_Architect.Core.Services
@using FFXIV_Craft_Architect.Web.Services
@using static FFXIV_Craft_Architect.Core.Models.MarketSortOption
@inject GarlandService GarlandService
@inject UniversalisService UniversalisService
@inject RecipeCalculationService RecipeCalculationService
@inject MarketShoppingService MarketShoppingService
@inject IMarketCacheService MarketCache
@inject ILogger<MarketAnalysis> Logger
@inject IJSRuntime JSRuntime
@inject ISnackbar Snackbar
@inject AppState AppState
@inject IndexedDbService IndexedDb
@inject NavigationManager NavigationManager
@implements IDisposable

<MudContainer MaxWidth="MaxWidth.ExtraExtraLarge" Class="pa-0 ma-page-container">
    <div class="ma-grid-layout">
        <MarketAnalysisControlsPanel
            AppState="AppState"
            BuyItems="GetBuyItems()"
            IsAnalyzing="_isAnalyzing"
            IsRefreshingPrices="_isRefreshingPrices"
            CanAnalyze="CanAnalyze()"
            CanRefreshPrices="CanRefreshPrices()"
            OnModeChangedRequested="OnModeChanged"
            OnRunAnalysisRequested="RunMarketAnalysisAsync"
            OnRefreshPricesRequested="RefreshPricesAsync"
            OnGoToPlannerRequested="GoToPlanner"
            OnGoToProcurementRequested="GoToProcurement" />

        <MarketAnalysisResultsPanel
            BuyItems="GetBuyItems()"
            ShoppingPlans="AppState.ShoppingPlans"
            CurrentSort="AppState.MarketSortPreference"
            AutoExpandItemId="AppState.AutoExpandItemId"
            IsAnalyzing="_isAnalyzing"
            OnGoToPlannerRequested="GoToPlanner"
            OnRunAnalysisRequested="RunMarketAnalysisAsync" />
    </div>
</MudContainer>

@code {
    private bool _isAnalyzing = false;
    private bool _isRefreshingPrices = false;
    
    // Settings now stored in AppState for persistence across page navigations

    protected override void OnInitialized()
    {
        // Subscribe to plan changes (including restoration from auto-save)
        AppState.OnPlanChanged += OnPlanChanged;
        AppState.OnShoppingListChanged += OnShoppingListChanged;
    }
    
    protected override void OnAfterRender(bool firstRender)
    {
        // Clear the auto-expand item ID after the first render
        // This ensures it doesn't persist if the user navigates away and back
        if (firstRender && AppState.AutoExpandItemId.HasValue)
        {
            AppState.AutoExpandItemId = null;
        }
    }

    private void OnPlanChanged()
    {
        InvokeAsync(StateHasChanged);
    }

    private void OnShoppingListChanged()
    {
        InvokeAsync(StateHasChanged);
    }

    public void Dispose()
    {
        AppState.OnPlanChanged -= OnPlanChanged;
        AppState.OnShoppingListChanged -= OnShoppingListChanged;
    }

    /// <summary>
    /// Get the current items marked for buying from the recipe plan.
    /// This dynamically reflects any changes made in the recipe tree.
    /// </summary>
    private List<MaterialAggregate> GetBuyItems()
    {
        if (AppState.CurrentPlan == null)
            return new List<MaterialAggregate>();
        
        return AppState.CurrentPlan.AggregatedMaterials
            .Where(m => m.TotalQuantity > 0)
            .ToList();
    }

    private bool CanAnalyze()
    {
        return GetBuyItems().Any() && !string.IsNullOrWhiteSpace(AppState.SelectedDataCenter);
    }
    
    private bool CanRefreshPrices()
    {
        return AppState.CurrentPlan != null && !string.IsNullOrWhiteSpace(AppState.SelectedDataCenter);
    }
    
    private async Task RefreshPricesAsync()
    {
        if (AppState.CurrentPlan == null) return;
        
        _isRefreshingPrices = true;
        AppState.BeginOperation("Refreshing Prices", "Fetching latest market data...");
        
        try
        {
            // Step 1: Fetch vendor prices
            await RecipeCalculationService.FetchVendorPricesAsync(AppState.CurrentPlan);
            Snackbar.Add("Vendor prices updated", Severity.Success);
            
            // Step 2: Fetch market prices
            var itemIds = AppState.CurrentPlan.GetAllItemIds().ToList();
            if (itemIds.Any())
            {
                AppState.SetStatus("Fetching market prices...", busy: true);
                var responses = await UniversalisService.GetMarketDataBulkAsync(
                    AppState.SelectedDataCenter, 
                    itemIds);
                
                // Update node prices
                UpdateNodeMarketPrices(AppState.CurrentPlan.RootItems, responses);
                Snackbar.Add("Market prices updated", Severity.Success);
            }
            
            AppState.NotifyPlanChanged();
            AppState.EndOperation("Prices refreshed successfully!");
        }
        catch (Exception ex)
        {
            AppState.SetStatus($"Price refresh failed: {ex.Message}");
            Snackbar.Add($"Failed to refresh prices: {ex.Message}", Severity.Error);
        }
        finally
        {
            _isRefreshingPrices = false;
        }
    }
    
    private void UpdateNodeMarketPrices(List<PlanNode> nodes, Dictionary<int, UniversalisResponse> responses)
    {
        foreach (var node in nodes)
        {
            if (responses.TryGetValue(node.ItemId, out var response))
            {
                node.MarketPrice = (decimal)response.AveragePrice;
                
                // Calculate HQ price if available
                var hqListings = response.Listings.Where(l => l.IsHq).ToList();
                if (hqListings.Any())
                {
                    node.HqMarketPrice = (decimal)hqListings.Average(l => l.PricePerUnit);
                }
            }
            
            // Recursively update children
            if (node.Children?.Any() == true)
            {
                UpdateNodeMarketPrices(node.Children, responses);
            }
        }
    }

    private async Task RunMarketAnalysisAsync()
    {
        var materials = GetBuyItems();
        
        if (!materials.Any() || string.IsNullOrWhiteSpace(AppState.SelectedDataCenter))
            return;

        _isAnalyzing = true;
        AppState.ShoppingPlans.Clear();
        AppState.BeginOperation("Market Analysis", $"Analyzing {materials.Count} items on {AppState.SelectedDataCenter}...");

        try
        {
            var progress = new Progress<string>(msg => AppState.SetStatus(msg, busy: true));
            
            // Step 1: Ensure cache is populated with market data (just like WPF app)
            var cacheRequests = materials.Select(m => (m.ItemId, AppState.SelectedDataCenter)).ToList();
            AppState.SetStatus($"Checking cache for {cacheRequests.Count} items...");
            var fetchedCount = await MarketCache.EnsurePopulatedAsync(cacheRequests, progress: progress);
            Logger.LogInformation("Market Analysis: {FetchedCount} items fetched from API", fetchedCount);
            
            // Step 2: Calculate shopping plans from cached data
            List<DetailedShoppingPlan> plans;
            
            if (AppState.SearchEntireRegion)
            {
                // Multi-DC analysis doesn't support splits yet
                plans = await MarketShoppingService.CalculateDetailedShoppingPlansMultiDCAsync(
                    materials,
                    progress,
                    mode: AppState.RecommendationMode);
            }
            else if (AppState.EnableMultiWorldSplits)
            {
                // Use split-aware calculation for single DC
                var config = new MarketAnalysisConfig
                {
                    EnableSplitWorld = AppState.EnableMultiWorldSplits,
                    MaxWorldsPerItem = AppState.MaxWorldsPerItem > 0 ? AppState.MaxWorldsPerItem : null
                };
                
                plans = await MarketShoppingService.CalculateShoppingPlansWithSplitsAsync(
                    materials,
                    AppState.SelectedDataCenter,
                    progress,
                    config: config);
            }
            else
            {
                // Standard single-world calculation
                plans = await MarketShoppingService.CalculateDetailedShoppingPlansAsync(
                    materials,
                    AppState.SelectedDataCenter,
                    progress,
                    mode: AppState.RecommendationMode);
            }
            
            // Apply vendor price overrides for vendor-buy items
            ApplyVendorPriceOverrides(plans);
            
            AppState.ShoppingPlans = plans;
            AppState.NotifyShoppingListChanged();
            
            // Save market analysis to the current plan for persistence
            if (AppState.CurrentPlanId != null)
            {
                await IndexedDb.SaveMarketAnalysisAsync(AppState.CurrentPlanId, plans, AppState.RecommendationMode);
            }
            
            var bestValue = AppState.ShoppingPlans.Sum(p => p.RecommendedWorld?.TotalCost ?? 0);
            // Ensure the status message is properly set to completion
            AppState.EndOperation($"Analysis complete! Best value: {bestValue:N0}g");
            Snackbar.Add("Market analysis complete!", Severity.Success);
        }
        catch (Exception ex)
        {
            AppState.SetStatus($"Analysis failed: {ex.Message}");
            Snackbar.Add($"Market analysis failed: {ex.Message}", Severity.Error);
        }
        finally
        {
            _isAnalyzing = false;
        }
    }

    /// <summary>
    /// For items marked as vendor-buy, override the recommendation to show vendor price.
    /// Keeps market data visible for comparison but sets vendor as the recommended option.
    /// Uses the selected vendor from the recipe plan (respects SelectedVendorIndex).
    /// </summary>
    private void ApplyVendorPriceOverrides(List<DetailedShoppingPlan> plans)
    {
        if (AppState.CurrentPlan == null) return;

        foreach (var plan in plans)
        {
            // Find the node in the plan tree to check its source and vendor price
            var node = FindNodeInPlan(AppState.CurrentPlan, plan.ItemId);
            if (node?.Source == AcquisitionSource.VendorBuy && node.VendorPrice > 0)
            {
                // Get the specific vendor selected in the recipe plan
                var selectedVendor = node.SelectedVendor;
                if (selectedVendor != null)
                {
                    // Create a vendor "world" option as the recommendation with specific vendor info
                    plan.RecommendedWorld = new WorldShoppingSummary
                    {
                        WorldName = "Vendor",
                        TotalCost = (long)(selectedVendor.Price * plan.QuantityNeeded),
                        AveragePricePerUnit = selectedVendor.Price,
                        TotalQuantityPurchased = plan.QuantityNeeded,
                        HasSufficientStock = true,
                        Listings = new List<ShoppingListingEntry>(),
                        // Store the specific vendor name for display
                        VendorName = $"{selectedVendor.Name} - {selectedVendor.Location}"
                    };

                    // Clear any split recommendations since vendor has unlimited stock
                    plan.RecommendedSplit = null;

                    // Use vendor data already stored in the node (no need to fetch again)
                    plan.Vendors = node.VendorOptions
                        .Where(v => v.IsGilVendor)
                        .ToList();

                    Logger.LogInformation("Applied vendor price override for {ItemName}: {VendorName} @ {VendorPrice}g",
                        plan.Name, selectedVendor.Name, selectedVendor.Price);
                }
            }
        }
    }
    
    /// <summary>
    /// Find a node in the plan tree by item ID.
    /// </summary>
    private PlanNode? FindNodeInPlan(CraftingPlan plan, int itemId)
    {
        foreach (var root in plan.RootItems)
        {
            var found = FindNodeRecursive(root, itemId);
            if (found != null) return found;
        }
        return null;
    }
    
    private PlanNode? FindNodeRecursive(PlanNode node, int itemId)
    {
        if (node.ItemId == itemId) return node;
        
        foreach (var child in node.Children)
        {
            var found = FindNodeRecursive(child, itemId);
            if (found != null) return found;
        }
        return null;
    }

    private async Task OnModeChanged(RecommendationMode mode)
    {
        AppState.RecommendationMode = mode;
        if (GetBuyItems().Any() && AppState.ShoppingPlans.Any())
        {
            await RunMarketAnalysisAsync();
        }
    }

    private void GoToPlanner()
    {
        // Use relative path (no leading slash) so it resolves against base href correctly
        NavigationManager.NavigateTo("./");
    }

    private void GoToProcurement()
    {
        // Use relative path (no leading slash) so it resolves against base href correctly
        NavigationManager.NavigateTo("procurement");
    }
}
