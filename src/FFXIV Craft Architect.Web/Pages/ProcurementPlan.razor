@page "/procurement"
@using FFXIV_Craft_Architect.Core.Models
@using FFXIV_Craft_Architect.Core.Services
@using FFXIV_Craft_Architect.Web.Services
@inject GarlandService GarlandService
@inject UniversalisService UniversalisService
@inject RecipeCalculationService RecipeCalculationService
@inject MarketShoppingService MarketShoppingService
@inject IJSRuntime JSRuntime
@inject ISnackbar Snackbar
@inject AppState AppState
@inject NavigationManager NavigationManager
@implements IDisposable

<MudContainer MaxWidth="MaxWidth.ExtraExtraLarge" Class="pa-0 pp-page-container">
    <div class="pp-grid-layout">
        <ProcurementControlsPanel
            AppState="AppState"
            IsAnalyzing="_isAnalyzing"
            CanAnalyze="CanAnalyze()"
            OnRunAnalysisRequested="RunAnalysisAsync"
            OnGoToPlannerRequested="GoToPlanner"
            OnGoToMarketAnalysisRequested="GoToMarketAnalysis" />

        <ProcurementResultsShell
            ShoppingPlans="AppState.ShoppingPlans"
            OnReanalyzeWithoutWorldRequested="ReanalyzeWithoutWorldAsync" />
    </div>
</MudContainer>

@code {
    private bool _isAnalyzing = false;

    protected override void OnInitialized()
    {
        // Subscribe to changes (including restoration from auto-save)
        AppState.OnPlanChanged += OnPlanChanged;
        AppState.OnShoppingListChanged += OnShoppingListChanged;
    }

    private void OnPlanChanged()
    {
        InvokeAsync(StateHasChanged);
    }

    private void OnShoppingListChanged()
    {
        InvokeAsync(StateHasChanged);
    }

    public void Dispose()
    {
        AppState.OnPlanChanged -= OnPlanChanged;
        AppState.OnShoppingListChanged -= OnShoppingListChanged;
    }

    private bool CanAnalyze()
    {
        return AppState.CurrentPlan != null && 
               GetBuyItems().Any() && 
               !string.IsNullOrWhiteSpace(AppState.SelectedDataCenter);
    }

    /// <summary>
    /// Get the current items marked for buying from the recipe plan.
    /// </summary>
    private List<MaterialAggregate> GetBuyItems()
    {
        if (AppState.CurrentPlan == null)
            return new List<MaterialAggregate>();
        
        return AppState.CurrentPlan.AggregatedMaterials
            .Where(m => m.TotalQuantity > 0)
            .ToList();
    }

    private async Task RunAnalysisAsync()
    {
        if (!CanAnalyze())
            return;

        _isAnalyzing = true;
        AppState.BeginOperation("Procurement Analysis", "Generating optimal procurement plan...");

        try
        {
            var materials = GetBuyItems();
            var progress = new Progress<string>(msg => AppState.SetStatus(msg, busy: true));
            
            // Use existing market analysis results if available and data center matches
            List<DetailedShoppingPlan> shoppingPlans;
            
            if (AppState.ShoppingPlans.Any() && AppState.ShoppingPlans.First().WorldOptions.Any())
            {
                // Reuse existing market analysis
                AppState.SetStatus("Using existing market analysis...", busy: true);
                shoppingPlans = AppState.ShoppingPlans;
            }
            else
            {
                // Run market analysis first
                AppState.SetStatus("Running market analysis first...", busy: true);
                shoppingPlans = await MarketShoppingService.CalculateDetailedShoppingPlansAsync(
                    materials,
                    AppState.SelectedDataCenter,
                    progress,
                    mode: AppState.RecommendationMode,
                    blacklistedWorlds: AppState.TemporarilyBlacklistedWorlds);
                
                AppState.ShoppingPlans = shoppingPlans;
                AppState.NotifyShoppingListChanged();
            }
            
            // Shopping plans are now the primary source of procurement data
            AppState.ShoppingPlans = shoppingPlans;
            AppState.NotifyShoppingListChanged();
            
            AppState.EndOperation("Shopping plans generated!");
            Snackbar.Add("Shopping plans generated successfully!", Severity.Success);
        }
        catch (Exception ex)
        {
            AppState.SetStatus($"Analysis failed: {ex.Message}");
            Snackbar.Add($"Procurement analysis failed: {ex.Message}", Severity.Error);
        }
        finally
        {
            _isAnalyzing = false;
        }
    }

    private void GoToPlanner()
    {
        // Use relative path (no leading slash) so it resolves against base href correctly
        NavigationManager.NavigateTo("./");
    }

    private void GoToMarketAnalysis()
    {
        // Use relative path (no leading slash) so it resolves against base href correctly
        NavigationManager.NavigateTo("market");
    }
    
    /// <summary>
    /// Re-runs analysis with the specified world blacklisted.
    /// Called when user clicks "Re-analyze without this world" on a congested world card.
    /// </summary>
    private async Task ReanalyzeWithoutWorldAsync(string worldName)
    {
        // Add world to temporary blacklist
        AppState.TemporarilyBlacklistedWorlds.Add(worldName);
        
        Snackbar.Add($"Re-analyzing without {worldName}...", Severity.Info);
        
        // Clear current shopping plans to force recalculation with blacklist
        AppState.ShoppingPlans = new List<DetailedShoppingPlan>();
        
        // Re-run the analysis
        await RunAnalysisAsync();
        
        // Show results
        var blacklistedCount = AppState.TemporarilyBlacklistedWorlds.Count;
        if (blacklistedCount > 0)
        {
            Snackbar.Add($"Analysis complete. Excluded worlds: {string.Join(", ", AppState.TemporarilyBlacklistedWorlds)}", Severity.Success);
        }
    }
}
