@page "/"
@using FFXIV_Craft_Architect.Core.Models
@using FFXIV_Craft_Architect.Core.Services
@using FFXIV_Craft_Architect.Web.Services
@using Microsoft.AspNetCore.Components.Forms
@inject GarlandService GarlandService
@inject UniversalisService UniversalisService
@inject RecipeCalculationService RecipeCalculationService
@inject IJSRuntime JSRuntime
@inject ISnackbar Snackbar
@inject AppState AppState
@inject IndexedDbService IndexedDb
@inject IMarketCacheService MarketCache
@inject ILogger<Index> Logger
@implements IDisposable

<!-- 3-Column Layout matching WPF -->
<div style="display: grid; grid-template-columns: 280px 1fr 350px; gap: 0; height: calc(100vh - 64px);">
    
    <!-- Left Column: Project Items -->
    <ProjectItemsPanel
        SearchQuery="@_searchQuery"
        SearchQueryChanged="OnSearchQueryChanged"
        OnSearchKeyUp="OnSearchKeyUp"
        IsSearching="@_isSearching"
        IsBuildingPlan="@_isBuildingPlan"
        ShowPlanActions="@(AppState.CurrentPlan != null || AppState.ProjectItems.Any())"
        LastAutoSave="@AppState.LastAutoSave"
        SearchResults="@_searchResults"
        ProjectItems="@AppState.ProjectItems"
        OnSearchRequested="SearchItemsAsync"
        OnAddProjectItem="AddProjectItem"
        OnToggleItemHq="ToggleItemHq"
        OnRemoveProjectItem="RemoveProjectItem"
        OnBuildPlanRequested="BuildPlanAsync"
        OnSavePlanRequested="SaveToBrowserAsync"
        OnExportPlanRequested="ExportPlanAsync" />
    
    <!-- Middle Column: Recipe Tree -->
    <RecipePlanPanel
        CurrentPlan="@AppState.CurrentPlan"
        SavedPlans="@AppState.SavedPlans"
        OnExpandAllRequested="ExpandAllRecipeNodes"
        OnCollapseAllRequested="CollapseAllRecipeNodes"
        OnLoadPlanRequested="LoadSavedPlanAsync"
        OnDeletePlanRequested="DeleteSavedPlanAsync"
        OnNodeSourceChanged="OnNodeSourceChanged"
        OnNodeHqChanged="OnNodeHqChanged" />

    <!-- Right Column: Shopping List -->
    <ShoppingListPanel
        CurrentPlan="@AppState.CurrentPlan" />
</div>

@code {
    private string _searchQuery = string.Empty;
    private bool _isSearching = false;
    private List<GarlandSearchResult> _searchResults = new();
    
    private bool _isBuildingPlan = false;
    private bool _isRefreshingPrices = false;

    protected override async Task OnInitializedAsync()
    {
        // Subscribe to state changes
        AppState.OnPlanChanged += OnPlanChanged;
        
        // Load saved plans list
        await RefreshSavedPlansListAsync();
        
        // Note: WorldData, auto-save restoration, and auto-save timer are now
        // all handled centrally in MainLayout.razor
    }

    private void OnPlanChanged()
    {
        InvokeAsync(StateHasChanged);
    }

    public void Dispose()
    {
        AppState.OnPlanChanged -= OnPlanChanged;
        
        // Note: Auto-save timer is now managed centrally in MainLayout.razor
    }

    private async Task RefreshSavedPlansListAsync()
    {
        var plans = await IndexedDb.LoadAllPlansAsync();
        AppState.SavedPlans = plans
            .Where(p => p.Id != "autosave") // Don't show autosave in list
            .Select(p => new StoredPlanSummary
            {
                Id = p.Id,
                Name = p.Name,
                ModifiedAt = p.ModifiedAt,
                SavedAt = p.SavedAt,
                DataCenter = p.DataCenter,
                ItemCount = p.ProjectItems.Count
            })
            .ToList();
        AppState.NotifySavedPlansChanged();
    }

    private async Task SearchItemsAsync()
    {
        if (string.IsNullOrWhiteSpace(_searchQuery))
            return;

        _isSearching = true;
        _searchResults.Clear();
        
        try
        {
            var results = await GarlandService.SearchAsync(_searchQuery);
            _searchResults = results.Take(10).ToList();
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Search failed: {ex.Message}", Severity.Error);
        }
        finally
        {
            _isSearching = false;
            StateHasChanged(); // Force re-render to update button text and results
        }
    }

    private void OnSearchKeyUp(KeyboardEventArgs e)
    {
        if (e.Key == "Enter")
        {
            _ = SearchItemsAsync();
        }
    }

    private Task OnSearchQueryChanged(string value)
    {
        _searchQuery = value;
        return Task.CompletedTask;
    }

    private Task ExpandAllRecipeNodes()
    {
        AppState.ExpandAllRecipeNodes();
        return Task.CompletedTask;
    }

    private Task CollapseAllRecipeNodes()
    {
        AppState.CollapseAllRecipeNodes();
        return Task.CompletedTask;
    }

    private void AddProjectItem(GarlandSearchResult result)
    {
        if (!AppState.ProjectItems.Any(i => i.Id == result.Id))
        {
            AppState.ProjectItems.Add(new ProjectItem
            {
                Id = result.Id,
                Name = result.Object.Name,
                IconId = result.Object.IconId,
                Quantity = 1,
                MustBeHq = false
            });
            AppState.NotifyPlanChanged();
        }
        
        _searchResults.Clear();
        _searchQuery = string.Empty;
    }

    private void RemoveProjectItem(ProjectItem item)
    {
        AppState.ProjectItems.Remove(item);
        AppState.NotifyPlanChanged();
    }

    private void ToggleItemHq(ProjectItem item)
    {
        item.MustBeHq = !item.MustBeHq;
        AppState.NotifyPlanChanged();
    }

    private async Task BuildPlanAsync()
    {
        if (!AppState.ProjectItems.Any() || _isBuildingPlan)
            return;

        _isBuildingPlan = true;
        StateHasChanged();
        
        try
        {
            var targetItems = AppState.ProjectItems.Select(i => (i.Id, i.Name, i.Quantity, i.MustBeHq)).ToList();
            
            // Step 1: Build the recipe tree
            AppState.CurrentPlan = await RecipeCalculationService.BuildPlanAsync(
                targetItems, 
                AppState.SelectedDataCenter, 
                string.Empty);
            
            // Step 2: Fetch prices for all items (craftable and buyable)
            AppState.BeginOperation("Fetching Prices", "Loading market prices for all materials...");
            await RefreshPricesAsync();
            
            // Step 3: Clear previous shopping plans
            AppState.ShoppingPlans.Clear();
            
            // Step 4: Populate shopping list with items marked as "buy" from recipe plan
            // These will be shown in Procurement Planner for potential analysis
            PopulateShoppingListFromPlan();
            
            AppState.EndOperation($"Plan built with {AppState.CurrentPlan.RootItems.Count} items. Go to Procurement Planner to analyze.");
            Snackbar.Add($"Plan built! Prices fetched. Go to Procurement Planner to run market analysis.", Severity.Success);
        }
        catch (Exception ex)
        {
            AppState.EndOperation($"Failed: {ex.Message}");
            Snackbar.Add($"Failed to build plan: {ex.Message}", Severity.Error);
        }
        finally
        {
            _isBuildingPlan = false;
        }
    }
    
    private void PopulateShoppingListFromPlan()
    {
        // Collect all items from the plan that are marked for buying
        // This includes leaf nodes (materials) and any craftable nodes the user set to "buy"
        var buyItems = new List<MarketShoppingItem>();
        
        foreach (var root in AppState.CurrentPlan?.RootItems ?? new List<PlanNode>())
        {
            CollectBuyItems(root, buyItems);
        }
        
        AppState.ShoppingItems = buyItems;
        AppState.NotifyShoppingListChanged();
    }
    
    private void CollectBuyItems(PlanNode node, List<MarketShoppingItem> buyItems)
    {
        // If this node is set to buy (or is uncraftable), add it to the shopping list
        if (node.Source == AcquisitionSource.MarketBuyNq || node.Source == AcquisitionSource.MarketBuyHq || node.IsUncraftable)
        {
            // Only add if not already in the list (aggregate quantities)
            var existing = buyItems.FirstOrDefault(i => i.Id == node.ItemId);
            if (existing != null)
            {
                existing.Quantity += node.Quantity;
            }
            else
            {
                buyItems.Add(new MarketShoppingItem
                {
                    Id = node.ItemId,
                    Name = node.Name,
                    IconId = node.IconId,
                    Quantity = node.Quantity
                });
            }
        }
        
        // Recursively check children
        if (node.Children?.Any() == true)
        {
            foreach (var child in node.Children)
            {
                CollectBuyItems(child, buyItems);
            }
        }
    }

    private async Task RefreshPricesAsync()
    {
        if (AppState.CurrentPlan == null)
            return;

        _isRefreshingPrices = true;
        
        try
        {
            // Fetch vendor prices (cheap, from Garland)
            await RecipeCalculationService.FetchVendorPricesAsync(AppState.CurrentPlan);
            
            // Fetch market prices (from Universalis)
            var allItemIds = CollectAllItemIds(AppState.CurrentPlan.RootItems);
            var responses = await UniversalisService.GetMarketDataBulkAsync(AppState.SelectedDataCenter, allItemIds);

            // Update nodes with market prices
            foreach (var root in AppState.CurrentPlan.RootItems)
            {
                UpdateNodePrices(root, responses);
            }

            // Cache fetched market data in IndexedDB for use by Market Analysis
            foreach (var kvp in responses)
            {
                var cachedData = ConvertResponseToCachedData(kvp.Key, AppState.SelectedDataCenter, kvp.Value);
                await MarketCache.SetAsync(kvp.Key, AppState.SelectedDataCenter, cachedData);
            }

            Logger.LogInformation("Cached {Count} market entries to IndexedDB", responses.Count);

            AppState.NotifyPlanChanged();
            
            Snackbar.Add("Prices updated (vendor + market)", Severity.Success);
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Failed to fetch prices: {ex.Message}", Severity.Error);
        }
        finally
        {
            _isRefreshingPrices = false;
            
            // Increment price version to trigger UI re-render in RecipeNodeView components
            AppState.CurrentPlan.PriceVersion++;
            
            Logger.LogInformation("Prices refreshed, version incremented to {Version}", AppState.CurrentPlan.PriceVersion);
        }
    }

    private static List<int> CollectAllItemIds(List<PlanNode> nodes)
    {
        var ids = new HashSet<int>();
        foreach (var node in nodes)
        {
            CollectItemIdsRecursive(node, ids);
        }
        return ids.ToList();
    }

    private static void CollectItemIdsRecursive(PlanNode node, HashSet<int> ids)
    {
        ids.Add(node.ItemId);
        foreach (var child in node.Children)
        {
            CollectItemIdsRecursive(child, ids);
        }
    }

    private static void UpdateNodePrices(PlanNode node, Dictionary<int, UniversalisResponse> responses)
    {
        if (responses.TryGetValue(node.ItemId, out var response))
        {
            node.MarketPrice = (decimal)response.AveragePrice;
            var hqListings = response.Listings.Where(l => l.IsHq).ToList();
            if (hqListings.Any())
            {
                node.HqMarketPrice = (decimal)hqListings.Average(l => l.PricePerUnit);
            }

            // Price version will be incremented in RefreshPricesAsync after all updates complete
        }

        foreach (var child in node.Children)
        {
            UpdateNodePrices(child, responses);
        }
    }

    /// <summary>
    /// Converts UniversalisResponse to CachedMarketData for IndexedDB storage.
    /// </summary>
    private static CachedMarketData ConvertResponseToCachedData(int itemId, string dataCenter, UniversalisResponse response)
    {
        var worlds = new List<CachedWorldData>();

        foreach (var worldListing in response.Listings.GroupBy(l => l.WorldName))
        {
            worlds.Add(new CachedWorldData
            {
                WorldName = worldListing.Key ?? "Unknown",
                Listings = worldListing.Select(l => new CachedListing
                {
                    Quantity = l.Quantity,
                    PricePerUnit = l.PricePerUnit,
                    RetainerName = l.RetainerName ?? "Unknown",
                    IsHq = l.IsHq
                }).ToList()
            });
        }

        return new CachedMarketData
        {
            ItemId = itemId,
            DataCenter = dataCenter,
            FetchedAtUnix = DateTimeOffset.UtcNow.ToUnixTimeSeconds(),
            DCAveragePrice = (decimal)(response.AveragePriceNq > 0 ? response.AveragePriceNq : response.AveragePrice),
            HQAveragePrice = response.AveragePriceHq > 0 ? (decimal)response.AveragePriceHq : null,
            Worlds = worlds
        };
    }

    private void OnNodeSourceChanged(PlanNode node)
    {
        // Recalculate shopping list when acquisition source changes
        PopulateShoppingListFromPlan();
        AppState.NotifyPlanChanged();
    }

    private void OnNodeHqChanged(PlanNode node)
    {
        AppState.NotifyPlanChanged();
    }

    private async Task SaveToBrowserAsync()
    {
        if (!AppState.ProjectItems.Any())
            return;

        try
        {
            // Use existing plan ID if available (overwrite), otherwise generate new
            var planId = AppState.CurrentPlanId ?? Guid.NewGuid().ToString();
            var planName = AppState.CurrentPlanName ?? AppState.CurrentPlan?.Name ?? $"Plan_{DateTime.Now:yyyyMMdd_HHmm}";
            
            // If this is a new save (no CurrentPlanId), set it for future overwrites
            if (AppState.CurrentPlanId == null)
            {
                AppState.CurrentPlanId = planId;
                AppState.CurrentPlanName = planName;
            }
            
            var planData = new StoredPlan
            {
                Id = planId,
                Name = planName,
                DataCenter = AppState.SelectedDataCenter,
                ModifiedAt = DateTime.UtcNow,
                ProjectItems = AppState.ProjectItems.Select(p => new StoredProjectItem
                {
                    Id = p.Id,
                    Name = p.Name,
                    IconId = p.IconId,
                    Quantity = p.Quantity,
                    MustBeHq = p.MustBeHq
                }).ToList(),
                PlanJson = AppState.CurrentPlan != null 
                    ? System.Text.Json.JsonSerializer.Serialize(AppState.CurrentPlan) 
                    : null
            };

            var success = await IndexedDb.SavePlanAsync(planData);
            if (success)
            {
                var action = AppState.CurrentPlanId == planId ? "Updated" : "Saved";
                Snackbar.Add($"{action} '{planName}' to browser storage", Severity.Success);
                await RefreshSavedPlansListAsync();
            }
            else
            {
                Snackbar.Add("Failed to save plan", Severity.Error);
            }
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Save failed: {ex.Message}", Severity.Error);
        }
    }

    private async Task LoadSavedPlanAsync(string planId)
    {
        try
        {
            var storedPlan = await IndexedDb.LoadPlanAsync(planId);
            if (storedPlan == null)
            {
                Snackbar.Add("Plan not found", Severity.Error);
                return;
            }

            CraftingPlan? plan = null;
            if (!string.IsNullOrEmpty(storedPlan.PlanJson))
            {
                try
                {
                    plan = System.Text.Json.JsonSerializer.Deserialize<CraftingPlan>(storedPlan.PlanJson);
                }
                catch (Exception ex)
                {
                    Snackbar.Add($"Warning: Could not load full plan data: {ex.Message}", Severity.Warning);
                }
            }

            AppState.LoadStoredPlan(storedPlan, plan);
            
            // Restore market analysis if available
            if (!string.IsNullOrEmpty(storedPlan.MarketPlansJson))
            {
                try
                {
                    var marketPlans = System.Text.Json.JsonSerializer.Deserialize<List<DetailedShoppingPlan>>(storedPlan.MarketPlansJson);
                    if (marketPlans?.Any() == true)
                    {
                        AppState.ShoppingPlans = marketPlans;
                        AppState.RecommendationMode = storedPlan.SavedRecommendationMode;
                        AppState.NotifyShoppingListChanged();
                    }
                }
                catch (Exception ex)
                {
                    Logger?.LogWarning(ex, "Failed to restore market analysis");
                }
            }
            
            Snackbar.Add($"Loaded '{storedPlan.Name}'", Severity.Success);
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Load failed: {ex.Message}", Severity.Error);
        }
    }

    private async Task DeleteSavedPlanAsync(string planId)
    {
        try
        {
            var success = await IndexedDb.DeletePlanAsync(planId);
            if (success)
            {
                Snackbar.Add("Plan deleted", Severity.Success);
                await RefreshSavedPlansListAsync();
            }
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Delete failed: {ex.Message}", Severity.Error);
        }
    }

    private async Task ExportPlanAsync()
    {
        if (AppState.CurrentPlan == null)
            return;

        try
        {
            var json = RecipeCalculationService.SerializePlan(AppState.CurrentPlan);
            var bytes = System.Text.Encoding.UTF8.GetBytes(json);
            var stream = new MemoryStream(bytes);
            
            using var streamRef = new DotNetStreamReference(stream);
            await JSRuntime.InvokeVoidAsync("downloadFileFromStream", $"{AppState.CurrentPlan.Name}.json", streamRef);
            
            Snackbar.Add("Plan exported to Downloads!", Severity.Success);
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Export failed: {ex.Message}", Severity.Error);
        }
    }

}
